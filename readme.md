
# Multithreading test with prime numbers

This is a program where I'm doing first steps in multithreading.  

This programm will be a console program finding all prime numbers from 0 to x (x is determined by user input).
Since I'm not trying to find an optimal prime detector algorithm I'm using nested loops to find the prime numbers.
Multiple versions of this algorithm will be compared. For that I'm going to measure the execution time.
All versions will store the found prime numbers in a vec so that they can be manipulated afterwards.

Since this will not be a performant solution for finding primes the limit within primes are searched will be restricted to usize.  
The usize datatype is an unsigned integer of pointer size.
unsigned 64 bit Integer => 0 to 18'446'744'073'709'551'615.

---

## Overview of the different implementations

Version 0 will use the crate 'primal' to get a trustable list for all primes to verify the prime number results of my implementations.  
Version 1.x implementations are used as a control group and for checking out if filtering even numbers and so out is an improvement.  
Version 2.x implementations use multithreading and individual vec with different merging methods.  
Version 3.x implementations use shared vecs instead and checks the efficiency of different place where sorting this vec occurs.  

***Not really sure what exactly will be done in the following versions:***  

Version 5.x implementations will use the Sieve of Eratosthenes to generate primes.  
Version 4.x implementations will use different data structures (fixed size heap array, linked list, etc...).  

### **Version 0**

Using crate primal as trustable control.

### **Version 1.0**

No multithreading, just brute force.  
Used to determine if my multithreading solution is actually helpful.  

### **Version 1.1**

No multithreading but if statements to filter out numbers divisible by 2.  

### **Version 2.0**

~~Using scoped threads, writing to individual vecs that will be merged in the end.~~  
~~Each spawned scope gets a subset of the total numbers to process.~~

This version is using rayon to parallelize the prime checking because I wasn't able to figure out
how to have the spawned threads not blocking. The original version may be revisited at a later date.  

### **Version 2.1**

~~Individual vecs will be merged in sorted order.~~  

Scrapped since the rayon version is already sorting the primes.

### **~~Version 3.0~~** - All Version 3.x are scrapped until a concurrent solution with custom threads is made

~~All threads will write to a shared buffer using locks.~~  

### **~~Version 3.1~~**

~~Shared vec will get sorted in the end.~~  

### **~~Version 3.2~~**

~~Found primes get inserted into the shared vec at the correct place.~~  

### **Version 4.0**

Try to implement my own Sieve of Eratosthenes algorithm. No parallelization.  

### **Version 4.1**

Try to implement my own Sieve of Eratosthenes algorithm. With parallelization.  

---

## Project Progress

- [x] Created program state which stores the data generated by the program
- [x] Console interface and accepting user input
- [x] Accept separated limit number for input (e.g. 1_000_000 or 1'000'000)
- [x] Function to print results to console
- [x] Function to wrap algorithm versions that measures their execution time
- [x] Function to check the results to baseline
- [x] Ability to rerun program
- [ ] Choosing which versions to run
  - maybe solve this using a builder pattern?
- [x] Version 0
- [x] Version 1.0
- [x] Version 1.1
- [x] Version 2.0
  - changed to using rayon crate
  - not yet without blocking
  - no improvement over v1 yet
- [ ] Version 2.1
  - scrapped due to changed 2.0
- [ ] Version 3.0
  - scrapped due to changed 2.0
- [ ] Version 3.1
  - scrapped due to changed 2.0
- [ ] Version 3.2
  - scrapped due to changed 2.0
- [ ] Version 4.0
- [ ] Version 4.1

Optional / not sure if I will implement
- [ ] Writing results to a file
- [ ] Version 5.x

---

## Crates used in this project

- Primal
- ClearScreen
- Rayon
- Thousands